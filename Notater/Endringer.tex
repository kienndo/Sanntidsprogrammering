---- MANGLER IMPLEMENTASJON AV ----------
master slave - hall assignment
hva skjer om vi kobler av

---------------HVORDAN SPLITTE MELLOM OM NOE ER CAB ELLER HALL--------------------------------
Jeg splittet Hall og Cab på requests i Elevator-structen
En måte å splitte mellom hall og cab:

func BtnEventSplitter(btnEvent chan elevio.ButtonEvent,
	hallEvent chan elevio.ButtonEvent,
	cabEvent chan elevio.ButtonEvent) {
	for {
		select {
		case event := <-btnEvent:
			if event.Button == elevio.BT_Cab {
				cabEvent <- event
			} else {
				hallEvent <- event
			}
		}
	}
}
---------------------REQUESTS, HALL OG CAB---------------------------------
Requests i Elevator-struct gjøres om til cab og hall slik at vi kan skille mellom, men vi lager en funksjon 
som likestiller dem ved requestfunksjoner i requests.go:
Request := requests_mergeHallAndCab(e.HallRequests, e.CabRequests)

Prøv å skjønne denne: 
func requests_mergeHallAndCab(hallRequests [elevio.N_FLOORS][2]bool, cabRequests [elevio.N_FLOORS]bool) [elevio.N_FLOORS][elevio.N_BUTTONS]bool {
	var requests [elevio.N_FLOORS][elevio.N_BUTTONS]bool
	for i := range requests {
		requests[i] = [elevio.N_BUTTONS]bool{hallRequests[i][0], hallRequests[i][1], cabRequests[i]}
	}
	return requests
}
func FSM_run(drv_buttons chan elevio.ButtonEvent, drv_floors chan int, drv_obstr chan bool, drv_stop chan bool, numFloors int) {

	//Motor direction for testing
	var d elevio.MotorDirection = elevio.MD_Up
	elevio.SetMotorDirection(d)


	// Checks the state of the different input-channels
	go elevio.PollButtons(drv_buttons)
	go elevio.PollFloorSensor(drv_floors)
	go elevio.PollObstructionSwitch(drv_obstr)
	go elevio.PollStopButton(drv_stop)

	// Infinite loop that checks the state of the different input-channels and does something every time it gets a signal
	select {
	case a := <-drv_buttons:
		fmt.Printf("%+v\n", a)
		elevio.SetButtonLamp(a.Button, a.Floor, true)

	case a := <-drv_floors:
		fmt.Printf("%+v\n", a)
		if a == numFloors-1 {
			d = elevio.MD_Down
		} else if a == 0 {
			d = elevio.MD_Up
		}
		elevio.SetMotorDirection(d)

	case a := <-drv_obstr:
		fmt.Printf("%+v\n", a)
		if a {
			elevio.SetMotorDirection(elevio.MD_Stop)
		} else {
			elevio.SetMotorDirection(d)
		}

	case a := <-drv_stop:
		fmt.Printf("%+v\n", a)
		for f := 0; f < numFloors; f++ {
			for b := elevio.ButtonType(0); b < 3; b++ {
				elevio.SetButtonLamp(b, f, false)
			}
		}
	}

}

for f := 0; f < elevio.N_FLOORS; f++ {
			for b := 0; b < elevio.N_BUTTONS; b++ {
				v := elevio.GetButton(elevio.ButtonType(b), f)
				if v != false && prevFloor[f][b] != v {
					fsm.FsmOnRequestButtonPress(f, elevio.ButtonType(b))
				}
				prevFloor[f][b] = v
			}
		}

		{
			// Floor sensor
			g := elevio.GetFloor()
			if g != -1 && g != previous {
				fsm.FsmOnFloorArrival(g)
			}
			previous = g
			

			if timer.TimerTimedOut() == 1 {
				timer.TimerStop()
				fsm.FsmOnDoorTimeout()
			}
		}

		case a := <-drv_obstr:
			//Obstruction
			fmt.Printf("%+v\n", a)
			fmt.Println("OBSTRUUUUUUUCTING!!!!!!!!!!")
			fsm.IsObstructed = a
		}

-----------------------Backup
const (
    udpPort     = 8000 // UDP port - må bytte port for mottaker(annen heis)
    checkPeriod = 1 * time.Second
)


func RunPrimary() {
    fmt.Println("Running as Primary")
	

    StartBackupProcess()
    if data, err := os.ReadFile("status.txt"); err == nil {
        if err := json.Unmarshal(data, &costfunctions.HRAElevator); err != nil {
            fmt.Println("Error unmarshaling JSON:", err)
        }
    }

    go func() {
        udpAddr, _ := net.ResolveUDPAddr("udp", fmt.Sprintf(":%d", udpPort)) 

        conn, _ := net.ListenUDP("udp", udpAddr)

        defer conn.Close()

        buf := make([]byte, 1024)
        for {
            n, _, _ := conn.ReadFromUDP(buf)

            var receivedData elevio.Elevator
            if err := json.Unmarshal(buf[:n], &receivedData); err != nil {
                fmt.Println("Error unmarshaling JSON:", err)
                continue
            }

            fmt.Println("Received message from backup:", receivedData)
        }
    }()

    for {
        //mt.Println(costfunctions.HRAElevator)

        os.WriteFile("status.txt", SerializeData(costfunctions.HRAElevator), 0666)

        SendUDPMessage("localhost", udpPort, costfunctions.HRAElevator)

        time.Sleep(1 * time.Second)
    }
}

func RunBackup() {
    fmt.Println("Running as Backup")
    
        if PrimaryIsActive() {
            fmt.Println("Primary is active")
        } else {
            fmt.Println("Primary is inactive, taking over.")
            RunPrimary()
            return
        }
        time.Sleep(checkPeriod)
}

func PrimaryIsActive() bool {
    info, _ := os.Stat("status.txt")

	PrimaryAlive := time.Since(info.ModTime()) < 2*checkPeriod
	//ChanAliveTX <- PrimaryAlive

    return PrimaryAlive
}

func StartBackupProcess() {
    cmd := exec.Command("gnome-terminal", "--", "go", "run", "main.go", "backup")

    if err := cmd.Start(); err != nil {
        fmt.Println("Failed to start backup process:", err)
    }
}

func SendUDPMessage(host string, port int, data elevio.Elevator) {
    jsonData, err := json.Marshal(data)
    if err != nil {
        fmt.Println("Error marshaling JSON:", err)
        return
    }

    udpAddr, _ := net.ResolveUDPAddr("udp", fmt.Sprintf("%s:%d", host, port))

    conn, err := net.DialUDP("udp", nil, udpAddr)
    if err != nil {
        fmt.Println("Error dialing UDP:", err)
        return
    }
    defer conn.Close()

    _, err = conn.Write(jsonData)
    if err != nil {
        fmt.Println("Error sending UDP message:", err)
        return
    }
}

func SerializeData(data elevio.Elevator) []byte {
    jsonData, err := json.Marshal(data)
    if err != nil {
        fmt.Println("Error marshaling JSON:", err)
        return nil
    }
    return jsonData
}

// func main() {
//     args := os.Args[1:]
//     if len(args) > 0 && args[0] == "backup" {
//         RunBackup()
//     } else {
//         RunPrimary()
//     }
// }

// ingrid
func ListenForPrimary() {
    conn, err := net.ListenPacket("udp", ":29500")
    if err != nil {
        fmt.Println("Error listening")
    }
    defer conn.Close()

    buffer := make([]byte, 1024)
    conn.SetReadDeadline(time.Now().Add(5*time.Second))

    // Dersom du leser melding hopper du ut av func
    _, _, err = conn.ReadFrom(buffer)
    if err != nil {
        return
    }

    fmt.Println("Backup started")

    //timer
    timer := time.NewTimer(10*time.Second)
    //addr, _ := net.ResolveUDPAddr("udp",":29500")

    for {
        select {
        case <-timer.C:
            fmt.Println("Timeout expired, becoming primary")
            return
        default:
            conn.SetReadDeadline(time.Now().Add(10 * time.Second))
            _, _, err := conn.ReadFrom(buffer)
            if err != nil {
                continue
            }
            fmt.Println("Message received, restart timer")
            if !timer.Stop() {
                <-timer.C
            }
            timer.Reset(10 * time.Second)
        }
    }

    // fortsetter å loope helt til primary dør
    // for {
    //     _, _, err := conn.ReadFrom(buffer)
    //     if err != nil {
    //         return
    //     }

    //     fmt.Println("Doing backupstuff")

    //     time.Sleep(2*time.Second)

    // }

}


// func SendState(state elevio.Elevator, addr string) {

// 	// Send states til master
// 	conn, err := net.Dial("udp","10.100.23.255"+addr)
// 	if err != nil {
// 		fmt.Println("Failed to dial UDP %vn", err)
// 		return
// 	}
// 	fmt.Println("kæser moren din kien")
// 	defer conn.Close()

// 	for {

// 	jsonData, err := json.Marshal(state)
// 	if err != nil {
// 		fmt.Println("failed to serialize data")
// 		return
// 	}

// 	_, err = conn.Write(jsonData)
// 	if err != nil {
// 		fmt.Println("failed to send state")
// 		return
// 	}

// 	// _, err := conn.Write([]byte("UDP connection funker på tide å kæse moren til kien"))
// 	// if err != nil {
// 	// 	fmt.Println("UDP connection funker ikke :(")
// 	// }
// 	time.Sleep(1*time.Second)
//  }
// }


